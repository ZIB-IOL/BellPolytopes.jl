var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = BellPolytopes","category":"page"},{"location":"#BellPolytopes","page":"Home","title":"BellPolytopes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BellPolytopes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [BellPolytopes]","category":"page"},{"location":"#BellPolytopes.bell_frank_wolfe-Union{Tuple{Array{T, N}}, Tuple{T}, Tuple{N}} where {N, T<:Number}","page":"Home","title":"BellPolytopes.bell_frank_wolfe","text":"Calls the lazy pairwise blended conditional gradient algorithm from Frank-Wolfe package.\n\nArguments:\n\np: a correlation tensor of order N.\n\nReturns:\n\nx: a correlation tensor of order N, the output of the Frank-Wolfe algorithm,\nds: a deterministic strategy, the atom returned by the last LMO,\nprimal: ½|x-v0*p|²\ndual_gap: <x-v0*p,x-ds>\ntraj_data: trajectory of the algorithm,\nactive_set: all deterministic strategies used for the decomposition of the last iterate x, contains fields weights, atoms, and x,\nM: a Bell inequality, meaningful only if the dual gap is small enough\nβ: the local bound of the inequality parametrised by M, reliable only if the last LMO is exact.\n\nOptional arguments:\n\nmarg: a boolean, indicates if p contains marginals\nv0: the visibility used to make a nonlocal p closer to the local polytope,\nepsilon: the tolerance, used as a stopping criterion (when the primal value or the dual gap go below its value), by default 1e-7,\nverbose: an integer, indicates the level of verbosity from 0 to 3,\nshr2: the potential underlying shrinking factor, used to display the lower bound in the callback,\nTD: type of the computations, by default the one of ̀p,\nmode: an integer, 0 is for the heuristic LMO, 1 for the enumeration LMO,\nnb: an integer, number of random tries in the LMO, if heuristic, by default 10^2,\nTL: type of the last call of the LMO,\nmode_last: an integer, mode of the last call of the LMO, -1 for no last call\nnb_last: an integer, number of random tries in the last LMO, if heuristic, by default 10^5,\nsym: a boolean, indicates if the symmetry of the input should be used, by default automatic choice,\nuse_array: a boolean, indicates to store the full deterministic strategies to trade memory for speed in multipartite scenarios,\ncallback_interval: an integer, print interval if verbose = 3.\n\n\n\n\n\n","category":"method"},{"location":"#BellPolytopes.nonlocality_threshold-Union{Tuple{TB}, Tuple{T}, Tuple{Union{Vector{TB}, AbstractMatrix{T} where T, TB}, Int64}} where {T<:Number, TB<:AbstractMatrix{T}}","page":"Home","title":"BellPolytopes.nonlocality_threshold","text":"Compute the nonlocality threshold of the qubit measurements encoded by the Bloch vectors vec in a Bell scenario with N parties.\n\nArguments:\n\nvec: an m × 3 matrix with Bloch vectors coordinates,\nN: the number of parties.\n\nReturns:\n\nlower_bound_infinite: a lower bound on the nonlocality threshold under all projective measurements (in the subspace spanned by vec in the Bloch sphere),\nlower_bound: a lower bound on the nonlocality threshold under the measurements provided in input,\nupper_bound: a (heuristic) upper bound on the nonlocality threshold under the measurements provided in input, also valid for all projective measurements\nlocal_model: a decomposition of the correlation tensor obtained by applying the measurements encoded by the Bloch vectors vec on all N subsystems of the shared state rho with visibility lower_bound,\nbell_inequality: a (heuristic) Bell inequality corresponding to upper_bound.\n\nOptional arguments:\n\nrho: the shared state, by default the singlet state in the bipartite case and the GHZ state otherwise,\nv0: the initial visibility, which should be an upper bound on the nonlocality threshold, 1.0 by default,\nprecision: number of digits of lower_bound, 4 by default,\nfor the other optional arguments, see bell_frank_wolfe.\n\n\n\n\n\n","category":"method"},{"location":"#BellPolytopes.pythagorean_approximation-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Number","page":"Home","title":"BellPolytopes.pythagorean_approximation","text":"Compute a rational approximation of a m × 3 Bloch matrix.\n\n\n\n\n\n","category":"method"},{"location":"#BellPolytopes.shrinking_squared-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Number","page":"Home","title":"BellPolytopes.shrinking_squared","text":"Compute the shrinking factor of a m × 3 Bloch matrix, symmetrising it to account for antipodal vectors.\n\n\n\n\n\n","category":"method"}]
}
